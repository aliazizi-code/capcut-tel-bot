import os
import time
import base64
import cv2
import numpy as np
import shutil
from pathlib import Path
from io import BytesIO
from dotenv import load_dotenv
from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
)
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from split_mp3 import get_split_mp3


load_dotenv()


async def test(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("success")

# ---------------- Browser Initialization ----------------
async def init_browser(context: ContextTypes.DEFAULT_TYPE):
    base_dir = os.path.dirname(os.path.abspath(__file__))
    download_dir = os.path.join(base_dir, "download")
    os.makedirs(download_dir, exist_ok=True)

    chrome_options = webdriver.ChromeOptions()
    chrome_options.add_experimental_option("prefs", {
        "download.default_directory": download_dir,
        "download.prompt_for_download": False,
        "download.directory_upgrade": True,
        "safebrowsing.enabled": True,
        "profile.default_content_setting_values.automatic_downloads": 1,
        "profile.default_content_setting_values.notifications": 2,
        "profile.default_content_setting_values.popups": 0,
        "profile.managed_default_content_settings.images": 2  # ‚õîÔ∏è ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ ŸÑŸàÿØ ÿ™ÿµÿßŸà€åÿ±
    })

    chrome_options.add_argument("--headless=new")  # ‚úÖ ÿ≠ÿßŸÑÿ™ ÿ®ÿØŸàŸÜ UI (headless)
    chrome_options.add_argument("--disable-gpu")
    chrome_options.add_argument("--no-sandbox")
    chrome_options.add_argument("--disable-dev-shm-usage")

    driver = webdriver.Chrome(options=chrome_options)
    context.application.bot_data["driver"] = driver
    return driver

# ---------------- /start Handler ----------------
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # ÿØÿ≥ÿ™ÿ±ÿ≥€å
    list_id = list(map(int, os.getenv("LIST_ID").split(',')))
    if update.effective_user.id not in list_id:
        return await update.message.reply_text("‚õîÔ∏è ÿØÿ≥ÿ™ÿ±ÿ≥€å ŸÜÿØÿßÿ±€åÿØ.")

    await update.message.reply_text("ÿØÿ± ÿ≠ÿßŸÑ ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ∂ÿπ€åÿ™...")

    # 1) ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿ±ÿß reuse ⁄©ŸÜ €åÿß ÿ®ÿ≥ÿßÿ≤
    bot_data = context.application.bot_data
    if "driver" in bot_data:
        driver = bot_data["driver"]
        try:
            _ = driver.title
            await update.message.reply_text("‚úÖ ŸÖÿ±Ÿàÿ±⁄Øÿ± ŸÇÿ®ŸÑÿßŸã ÿ®ÿßÿ≤ ÿ¥ÿØŸá Ÿà ŸÅÿπÿßŸÑŸá.")
        except Exception:
            await update.message.reply_text("üîÑ ŸÖÿ±Ÿàÿ±⁄Øÿ± ŸÇÿ®ŸÑ€å ÿ®ÿ≥ÿ™Ÿá ÿ¥ÿØŸá. ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÖÿ¨ÿØÿØ...")
            driver = await init_browser(context)
    else:
        driver = await init_browser(context)

    wait = WebDriverWait(driver, timeout=30)
    driver.get(os.getenv("LOGIN_URL"))

    # 2) ÿ®ÿ±ÿ±ÿ≥€å ŸÑÿß⁄Ø€åŸÜ ÿ®ŸàÿØŸÜ
    if not driver.find_elements(By.NAME, "signUsername"):
        return await update.message.reply_text("‚úÖ ŸÇÿ®ŸÑÿßŸã ŸÑÿß⁄Ø€åŸÜ ÿ¥ÿØŸá‚Äåÿß€åÿØ.")

    # 3) ŸÑÿß⁄Ø€åŸÜ
    await update.message.reply_text("üîê ŸÑÿß⁄Ø€åŸÜ ŸÜ€åÿ≥ÿ™€åÿØ ‚Äî ÿØÿ± ÿ≠ÿßŸÑ ŸÑÿß⁄Ø€åŸÜ...")
    try:
        btn = wait.until(EC.element_to_be_clickable(
            (By.XPATH, "//span[text()='Continue with CapCut Mobile']")))
        btn.click()
        await update.message.reply_text("‚úÖ ÿ±Ÿà€å ÿØ⁄©ŸÖŸá ŸÑÿß⁄Ø€åŸÜ ⁄©ŸÑ€å⁄© ÿ¥ÿØ.")

        # ŸæÿßŸæ‚Äåÿ¢Ÿæ QR
        time.sleep(2)
        main_win = driver.current_window_handle
        popups = [w for w in driver.window_handles if w != main_win]
        if not popups:
            return await update.message.reply_text("‚ùå ŸæŸÜÿ¨ÿ±Ÿá QR ÿ®ÿßÿ≤ ŸÜÿ¥ÿØ.")
        driver.switch_to.window(popups[0])

        # canvas ‚Üí ÿ™ÿµŸà€åÿ±
        canvas = wait.until(EC.presence_of_element_located((By.TAG_NAME, "canvas")))
        data_b64 = driver.execute_script(
            "return arguments[0].toDataURL('image/png').split(',')[1];", canvas
        )
        img_data = base64.b64decode(data_b64)
        arr = np.frombuffer(img_data, np.uint8)
        img_np = cv2.imdecode(arr, cv2.IMREAD_COLOR)

        # encode to PNG for telegram
        ok, buf = cv2.imencode(".png", img_np)
        if not ok:
            return await update.message.reply_text("‚ùå ÿ™ÿ®ÿØ€åŸÑ ÿ™ÿµŸà€åÿ± ÿ®Ÿá ÿ®ÿß€åÿ™‚Äå ÿ¥⁄©ÿ≥ÿ™ ÿÆŸàÿ±ÿØ.")
        bio = BytesIO(buf.tobytes())
        bio.name = "qr.png"
        bio.seek(0)
        await update.message.reply_photo(photo=bio)

        # ÿµÿ®ÿ± ÿ®ÿ±ÿß€å ÿ®ÿ≥ÿ™Ÿá‚Äåÿ¥ÿØŸÜ ŸæÿßŸæ‚Äåÿ¢Ÿæ
        while len(driver.window_handles) > 1:
            time.sleep(1)
        driver.switch_to.window(main_win)
        await update.message.reply_text("‚úÖ ÿ®ÿßÿ≤⁄Øÿ¥ÿ™ ÿ®Ÿá ŸæŸÜÿ¨ÿ±Ÿá ÿßÿµŸÑ€å")

    except Exception as e:
        return await update.message.reply_text(f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± ŸÑÿß⁄Ø€åŸÜ: {e}")

    # 4) Accept all
    try:
        time.sleep(5)
        accepts = driver.find_elements(By.XPATH, "//span[text()='Accept all']/ancestor::button")
        if accepts:
            accepts[0].click()
            await update.message.reply_text("‚úÖ 'Accept all' ⁄©ŸÑ€å⁄© ÿ¥ÿØ")
    except Exception as e:
        await update.message.reply_text(f"‚ö†Ô∏è ÿÆÿ∑ÿß ÿØÿ± Accept all: {e}")

    await update.message.reply_text(" Ÿà ŸÖŸÜÿ™ÿ∏ÿ± ÿßÿ±ÿ≥ÿßŸÑ ŸÅÿß€åŸÑ ÿµŸàÿ™€å Ÿáÿ≥ÿ™ŸÖ.  üéâ ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿ®ÿßÿ≤ ŸÖÿßŸÜÿØŸá ÿßÿ≥ÿ™.")

# ---------------- Mp3 Upload Handler ----------------


async def handle_mp3_audio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    driver = context.application.bot_data.get("driver")
    if not driver:
        return await update.message.reply_text("‚ùå ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿ±ÿßŸá‚ÄåÿßŸÜÿØÿßÿ≤€å ŸÜÿ¥ÿØŸáÿõ ÿßÿ®ÿ™ÿØÿß /start ÿ®ÿ≤ŸÜ€åÿØ.")

    audio = update.message.audio
    if not audio or audio.mime_type != "audio/mpeg":
        return await update.message.reply_text("‚ùå ŸÅŸÇÿ∑ ŸÅÿß€åŸÑ‚ÄåŸáÿß€å MP3 Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ŸÖ€å‚Äåÿ¥ŸàŸÜÿØ.")

    character_name = (update.message.caption or "").strip()
    if not character_name:
        return await update.message.reply_text("‚ùå ŸÑÿ∑ŸÅÿßŸã ŸÜÿßŸÖ ⁄©ÿ±⁄©ÿ™ÿ± ÿ±ÿß ÿØÿ± ⁄©Ÿæÿ¥ŸÜ ŸÅÿß€åŸÑ MP3 ÿ®ŸÜŸà€åÿ≥€åÿØ (ŸÖÿ´ŸÑÿßŸã: Pam).")

    # ÿ∞ÿÆ€åÿ±Ÿá ÿØÿ± ŸæŸàÿ¥Ÿá input
    base_dir = Path(os.path.dirname(os.path.abspath(__file__)))
    input_dir = base_dir / "input"
    input_dir.mkdir(exist_ok=True)
    file_name = audio.file_name or "input.mp3"
    input_path = input_dir / file_name

    await update.message.reply_text("üì• ÿØÿ± ÿ≠ÿßŸÑ ÿ∞ÿÆ€åÿ±Ÿá ŸÅÿß€åŸÑ ÿØÿ± ŸæŸàÿ¥Ÿá input‚Ä¶")
    tg_file = await audio.get_file()
    await tg_file.download_to_drive(str(input_path))

    # Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÅÿß€åŸÑ
    await update.message.reply_text("üéõ ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÅÿß€åŸÑ Ÿà ÿ™ŸÇÿ≥€åŸÖ ÿ®Ÿá ÿ®ÿÆÿ¥‚ÄåŸáÿß‚Ä¶")
    splits_dir = base_dir / "splits"
    get_split_mp3(str(input_path), output_base_dir=splits_dir)

    download_dir = base_dir / "download"
    download_dir.mkdir(exist_ok=True)


    driver.refresh()
    WebDriverWait(driver, 30).until(lambda d: d.execute_script("return document.readyState") == "complete")
    await update.message.reply_text("üîÑ ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿ±ŸÅÿ±ÿ¥ ÿ¥ÿØ.")
    wait = WebDriverWait(driver, 30)


    # ÿ¢ŸæŸÑŸàÿØ ŸáŸÖŸá ŸÅÿß€åŸÑ‚ÄåŸáÿß
    split_files = sorted(splits_dir.glob("*.mp3"), key=lambda f: int(f.stem))
    if not split_files:
        return await update.message.reply_text("‚ö†Ô∏è Ÿá€å⁄Ü ŸÅÿß€åŸÑ MP3 ÿØÿ± ŸæŸàÿ¥Ÿá splits Ÿæ€åÿØÿß ŸÜÿ¥ÿØ.")

    for file in split_files:
        try:
            driver.refresh()
            WebDriverWait(driver, 30).until(lambda d: d.execute_script("return document.readyState") == "complete")
            await update.message.reply_text("üîÑ ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿ±ŸÅÿ±ÿ¥ ÿ¥ÿØ.")
            wait = WebDriverWait(driver, 30)
            
            item_xpath = (
                f"//div[contains(@class,'toneItem-zsczqb')]"
                f"[.//div[contains(@class,'toneItem__name') and normalize-space(text())='{character_name}']]"
            )
            item = wait.until(EC.element_to_be_clickable((By.XPATH, item_xpath)))
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", item)
            driver.execute_script("arguments[0].click();", item)
            driver.execute_script("arguments[0].classList.add('toneItem--selected-ZwhzHN');", item)
            await update.message.reply_text(f"üé≠ ⁄©ÿ±⁄©ÿ™ÿ± ¬´{character_name}¬ª ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØ.")
            
            await update.message.reply_text(f"üì§ ÿ¢ŸæŸÑŸàÿØ ŸÅÿß€åŸÑ: {file.name}")
            file_input = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "input[type='file']")))
            driver.execute_script(
                "arguments[0].style.display='block'; arguments[0].style.visibility='visible';", file_input
            )
            file_input.send_keys(str(file.resolve()))

            generate_btn = wait.until(EC.element_to_be_clickable((By.XPATH, "//button[span/text()='Generate']")))
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", generate_btn)
            driver.execute_script("arguments[0].click();", generate_btn)
            await update.message.reply_text("‚ñ∂Ô∏è ÿØ⁄©ŸÖŸá Generate ⁄©ŸÑ€å⁄© ÿ¥ÿØ.")

            # ⁄©ŸÑ€å⁄© ÿ±Ÿà€å Download > Audio only
            download_btn = wait.until(EC.element_to_be_clickable((
                By.XPATH, "//div[contains(@class,'download-button') and .//span[text()='Download']]"
            )))
            driver.execute_script("arguments[0].scrollIntoView({block: 'center'});", download_btn)
            driver.execute_script("arguments[0].click();", download_btn)

            dropdown_item = wait.until(EC.element_to_be_clickable((
                By.XPATH, "//div[@role='menuitem' and contains(text(),'Audio only')]"
            )))
            dropdown_item.click()

            # ÿµÿ®ÿ± ÿ®ÿ±ÿß€å ÿ∞ÿÆ€åÿ±Ÿá ŸÅÿß€åŸÑ
            await update.message.reply_text("‚¨áÔ∏è ÿØÿ± ÿ≠ÿßŸÑ ÿØÿßŸÜŸÑŸàÿØ ŸÅÿß€åŸÑ ÿÆÿ±Ÿàÿ¨€å‚Ä¶")
            timeout = 60
            start = time.time()
            downloaded_file = None
            while time.time() - start < timeout:
                files = list(download_dir.glob("*.mp3"))
                files = [
                    f for f in files
                    if not f.name.endswith(".crdownload") and os.access(f, os.R_OK)
                ]
                if files:
                    newest = max(files, key=lambda f: f.stat().st_mtime)
                    if time.time() - newest.stat().st_mtime > 1:
                        downloaded_file = newest
                        break
                time.sleep(1)

            if downloaded_file:
                await update.message.reply_text(f"‚úÖ ŸÅÿß€åŸÑ ÿØÿßŸÜŸÑŸàÿØ ÿ¥ÿØ: {downloaded_file.name}")
            else:
                # await update.message.reply_text("‚ö†Ô∏è ŸÅÿß€åŸÑ ÿÆÿ±Ÿàÿ¨€å ÿØÿ±€åÿßŸÅÿ™ ŸÜÿ¥ÿØ.")
                pass
        except Exception as e:
            await update.message.reply_text(f"‚ùå ÿÆÿ∑ÿß ÿØÿ± ŸÅÿß€åŸÑ {file.name}: {e}")
            
    driver.refresh()
    WebDriverWait(driver, 30).until(lambda d: d.execute_script("return document.readyState") == "complete")
    await update.message.reply_text("üîÑ ŸÖÿ±Ÿàÿ±⁄Øÿ± ÿ±ŸÅÿ±ÿ¥ ÿ¥ÿØ.")
    wait = WebDriverWait(driver, 30)

    await update.message.reply_text("üéâ ÿ™ŸÖÿßŸÖ ŸÅÿß€åŸÑ‚ÄåŸáÿß Ÿæÿ±ÿØÿßÿ≤ÿ¥ÿå ÿ¢ŸæŸÑŸàÿØ Ÿà ÿØÿßŸÜŸÑŸàÿØ ÿ¥ÿØŸÜÿØ.")

# ---------------- Main ----------------
def main():
    app = ApplicationBuilder().token(os.getenv("BOT_TOKEN")).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("test", test))
    app.add_handler(MessageHandler(filters.AUDIO & ~filters.COMMAND, handle_mp3_audio))
    app.run_polling()

if __name__ == "__main__":
    main()